"""
Data Synchronization Service for ACSO Phase 5 Agentic Demonstrations.

This module provides real-time data synchronization capabilities across demo components,
including cross-component data consistency, conflict resolution, and distributed state management.
"""

import asyncio
import json
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set, Callable, Tuple
from enum import Enum
from dataclasses import dataclass, field
from copy import deepcopy
import logging

from .demo_data_store import DataType, demo_data_store

logger = logging.getLogger(__name__)


class SyncOperation(str, Enum):
    """Types of synchronization operations."""
    PUSH = "push"
    PULL = "pull"
    MERGE = "merge"
    CONFLICT_RESOLVE = "conflict_resolve"
    BROADCAST = "broadcast"


class ConflictResolution(str, Enum):
    """Conflict resolution strategies."""
    LAST_WRITE_WINS = "last_write_wins"
    FIRST_WRITE_WINS = "first_write_wins"
    MERGE_VALUES = "merge_values"
    MANUAL_RESOLVE = "manual_resolve"
    PRIORITY_BASED = "priority_based"


@dataclass
class SyncEvent:
    """Represents a synchronization event."""
    event_id: str
    timestamp: datetime
    operation: SyncOperation
    source_store: str
    target_stores: List[str]
    data_type: DataType
    key: str
    value: Any
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "event_id": self.event_id,
            "timestamp": self.timestamp.isoformat(),
            "operation": self.operation.value,
            "source_store": self.source_store,
            "target_stores": self.target_stores,
            "data_type": self.data_type.value,
            "key": self.key,
            "value": self.value,
            "metadata": self.metadata
        }


@dataclass
class ConflictEvent:
    """Represents a data conflict that needs resolution."""
    conflict_id: str
    timestamp: datetime
    data_type: DataType
    key: str
    conflicting_values: Dict[str, Any]  # store_id -> value
    resolution_strategy: ConflictResolution
    resolved: bool = False
    resolution_value: Any = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "conflict_id": self.conflict_id,
            "timestamp": self.timestamp.isoformat(),
            "data_type": self.data_type.value,
            "key": self.key,
            "conflicting_values": self.conflicting_values,
            "resolution_strategy": self.resolution_strategy.value,
            "resolved": self.resolved,
            "resolution_value": self.resolution_value,
            "metadata": self.metadata
        }


class DataSyncService:
    """Service for synchronizing data across demo components."""
    
    def __init__(self):
        self.sync_groups: Dict[str, Set[str]] = {}  # group_id -> store_ids
        self.sync_rules: Dict[str, Dict[str, Any]] = {}  # rule_id -> rule config
        self.conflict_handlers: Dict[ConflictResolution, Callable] = {}
        self.sync_events: List[SyncEvent] = []
        self.conflicts: Dict[str, ConflictEvent] = {}
        self.subscribers: List[Callable] = []
        
        # Configuration
        self.config = {
            "sync_interval": 1.0,  # seconds
            "conflict_timeout": 30.0,  # seconds
            "max_sync_events": 1000,
            "enable_real_time_sync": True,
            "default_conflict_resolution": ConflictResolution.LAST_WRITE_WINS
        }\n        \n        # Initialize conflict handlers\n        self._init_conflict_handlers()\n        \n        # Background tasks\n        self._sync_task: Optional[asyncio.Task] = None\n        self._conflict_resolution_task: Optional[asyncio.Task] = None\n        \n    def _init_conflict_handlers(self):\n        \"\"\"Initialize built-in conflict resolution handlers.\"\"\"\n        self.conflict_handlers[ConflictResolution.LAST_WRITE_WINS] = self._resolve_last_write_wins\n        self.conflict_handlers[ConflictResolution.FIRST_WRITE_WINS] = self._resolve_first_write_wins\n        self.conflict_handlers[ConflictResolution.MERGE_VALUES] = self._resolve_merge_values\n        self.conflict_handlers[ConflictResolution.PRIORITY_BASED] = self._resolve_priority_based\n        \n    async def start(self) -> bool:\n        \"\"\"Start the synchronization service.\"\"\"\n        try:\n            if self.config[\"enable_real_time_sync\"]:\n                self._sync_task = asyncio.create_task(self._sync_loop())\n                \n            self._conflict_resolution_task = asyncio.create_task(self._conflict_resolution_loop())\n            \n            logger.info(\"Data synchronization service started\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to start sync service: {e}\")\n            return False\n            \n    async def stop(self):\n        \"\"\"Stop the synchronization service.\"\"\"\n        if self._sync_task:\n            self._sync_task.cancel()\n            try:\n                await self._sync_task\n            except asyncio.CancelledError:\n                pass\n                \n        if self._conflict_resolution_task:\n            self._conflict_resolution_task.cancel()\n            try:\n                await self._conflict_resolution_task\n            except asyncio.CancelledError:\n                pass\n                \n        logger.info(\"Data synchronization service stopped\")\n        \n    async def create_sync_group(self, group_id: str, store_ids: List[str]) -> bool:\n        \"\"\"Create a synchronization group.\"\"\"\n        try:\n            # Validate stores exist\n            for store_id in store_ids:\n                store = await demo_data_store.get_store(store_id)\n                if not store:\n                    logger.error(f\"Store {store_id} not found\")\n                    return False\n                    \n            self.sync_groups[group_id] = set(store_ids)\n            logger.info(f\"Created sync group {group_id} with stores: {store_ids}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to create sync group {group_id}: {e}\")\n            return False\n            \n    async def add_to_sync_group(self, group_id: str, store_id: str) -> bool:\n        \"\"\"Add a store to a synchronization group.\"\"\"\n        if group_id not in self.sync_groups:\n            logger.error(f\"Sync group {group_id} not found\")\n            return False\n            \n        store = await demo_data_store.get_store(store_id)\n        if not store:\n            logger.error(f\"Store {store_id} not found\")\n            return False\n            \n        self.sync_groups[group_id].add(store_id)\n        logger.info(f\"Added store {store_id} to sync group {group_id}\")\n        return True\n        \n    async def remove_from_sync_group(self, group_id: str, store_id: str) -> bool:\n        \"\"\"Remove a store from a synchronization group.\"\"\"\n        if group_id not in self.sync_groups:\n            logger.error(f\"Sync group {group_id} not found\")\n            return False\n            \n        self.sync_groups[group_id].discard(store_id)\n        logger.info(f\"Removed store {store_id} from sync group {group_id}\")\n        return True\n        \n    async def create_sync_rule(self, rule_id: str, config: Dict[str, Any]) -> bool:\n        \"\"\"Create a synchronization rule.\"\"\"\n        try:\n            # Validate rule configuration\n            required_fields = [\"data_types\", \"sync_groups\", \"conflict_resolution\"]\n            for field in required_fields:\n                if field not in config:\n                    logger.error(f\"Missing required field {field} in sync rule\")\n                    return False\n                    \n            # Validate data types\n            for data_type_str in config[\"data_types\"]:\n                try:\n                    DataType(data_type_str)\n                except ValueError:\n                    logger.error(f\"Invalid data type: {data_type_str}\")\n                    return False\n                    \n            # Validate conflict resolution\n            try:\n                ConflictResolution(config[\"conflict_resolution\"])\n            except ValueError:\n                logger.error(f\"Invalid conflict resolution: {config['conflict_resolution']}\")\n                return False\n                \n            self.sync_rules[rule_id] = config\n            logger.info(f\"Created sync rule {rule_id}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to create sync rule {rule_id}: {e}\")\n            return False\n            \n    async def sync_data(self, source_store_id: str, target_store_ids: List[str],\n                       data_type: DataType, key: str, value: Any,\n                       metadata: Optional[Dict[str, Any]] = None) -> bool:\n        \"\"\"Synchronize specific data across stores.\"\"\"\n        try:\n            # Create sync event\n            sync_event = SyncEvent(\n                event_id=str(uuid.uuid4()),\n                timestamp=datetime.utcnow(),\n                operation=SyncOperation.PUSH,\n                source_store=source_store_id,\n                target_stores=target_store_ids,\n                data_type=data_type,\n                key=key,\n                value=deepcopy(value),\n                metadata=metadata or {}\n            )\n            \n            # Check for conflicts\n            conflicts = await self._detect_conflicts(sync_event)\n            \n            if conflicts:\n                # Handle conflicts\n                for conflict in conflicts:\n                    await self._handle_conflict(conflict)\n                    \n            else:\n                # Apply sync\n                await self._apply_sync_event(sync_event)\n                \n            # Record event\n            self.sync_events.append(sync_event)\n            \n            # Trim event history\n            if len(self.sync_events) > self.config[\"max_sync_events\"]:\n                self.sync_events = self.sync_events[-self.config[\"max_sync_events\"]:]\n                \n            # Notify subscribers\n            await self._notify_subscribers(sync_event)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to sync data: {e}\")\n            return False\n            \n    async def broadcast_data(self, group_id: str, data_type: DataType,\n                           key: str, value: Any, source_store_id: str,\n                           metadata: Optional[Dict[str, Any]] = None) -> bool:\n        \"\"\"Broadcast data to all stores in a sync group.\"\"\"\n        if group_id not in self.sync_groups:\n            logger.error(f\"Sync group {group_id} not found\")\n            return False\n            \n        target_stores = [store_id for store_id in self.sync_groups[group_id] \n                        if store_id != source_store_id]\n        \n        return await self.sync_data(\n            source_store_id, target_stores, data_type, key, value, metadata\n        )\n        \n    async def _detect_conflicts(self, sync_event: SyncEvent) -> List[ConflictEvent]:\n        \"\"\"Detect conflicts for a sync event.\"\"\"\n        conflicts = []\n        \n        try:\n            # Check each target store for conflicts\n            for target_store_id in sync_event.target_stores:\n                target_store = await demo_data_store.get_store(target_store_id)\n                if not target_store:\n                    continue\n                    \n                existing_value = await target_store.get(sync_event.data_type, sync_event.key)\n                \n                # Check if values are different\n                if existing_value is not None and existing_value != sync_event.value:\n                    conflict = ConflictEvent(\n                        conflict_id=str(uuid.uuid4()),\n                        timestamp=datetime.utcnow(),\n                        data_type=sync_event.data_type,\n                        key=sync_event.key,\n                        conflicting_values={\n                            sync_event.source_store: sync_event.value,\n                            target_store_id: existing_value\n                        },\n                        resolution_strategy=self.config[\"default_conflict_resolution\"],\n                        metadata={\n                            \"sync_event_id\": sync_event.event_id,\n                            \"detected_at\": datetime.utcnow().isoformat()\n                        }\n                    )\n                    \n                    conflicts.append(conflict)\n                    \n        except Exception as e:\n            logger.error(f\"Error detecting conflicts: {e}\")\n            \n        return conflicts\n        \n    async def _handle_conflict(self, conflict: ConflictEvent) -> bool:\n        \"\"\"Handle a data conflict.\"\"\"\n        try:\n            # Store conflict for tracking\n            self.conflicts[conflict.conflict_id] = conflict\n            \n            # Get resolution handler\n            handler = self.conflict_handlers.get(conflict.resolution_strategy)\n            if not handler:\n                logger.error(f\"No handler for resolution strategy: {conflict.resolution_strategy}\")\n                return False\n                \n            # Resolve conflict\n            resolution_value = await handler(conflict)\n            \n            if resolution_value is not None:\n                conflict.resolution_value = resolution_value\n                conflict.resolved = True\n                \n                # Apply resolution to all conflicting stores\n                for store_id in conflict.conflicting_values.keys():\n                    store = await demo_data_store.get_store(store_id)\n                    if store:\n                        await store.set(\n                            conflict.data_type,\n                            conflict.key,\n                            resolution_value,\n                            {\n                                \"conflict_resolved\": True,\n                                \"conflict_id\": conflict.conflict_id,\n                                \"resolution_strategy\": conflict.resolution_strategy.value\n                            }\n                        )\n                        \n                logger.info(f\"Resolved conflict {conflict.conflict_id}\")\n                return True\n            else:\n                logger.warning(f\"Failed to resolve conflict {conflict.conflict_id}\")\n                return False\n                \n        except Exception as e:\n            logger.error(f\"Error handling conflict {conflict.conflict_id}: {e}\")\n            return False\n            \n    async def _apply_sync_event(self, sync_event: SyncEvent) -> bool:\n        \"\"\"Apply a sync event to target stores.\"\"\"\n        try:\n            for target_store_id in sync_event.target_stores:\n                target_store = await demo_data_store.get_store(target_store_id)\n                if target_store:\n                    await target_store.set(\n                        sync_event.data_type,\n                        sync_event.key,\n                        sync_event.value,\n                        {\n                            **sync_event.metadata,\n                            \"synced_from\": sync_event.source_store,\n                            \"sync_event_id\": sync_event.event_id,\n                            \"sync_timestamp\": sync_event.timestamp.isoformat()\n                        }\n                    )\n                    \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error applying sync event: {e}\")\n            return False\n            \n    async def _resolve_last_write_wins(self, conflict: ConflictEvent) -> Any:\n        \"\"\"Resolve conflict using last write wins strategy.\"\"\"\n        # Find the most recent value based on timestamps\n        latest_timestamp = None\n        latest_value = None\n        \n        for store_id, value in conflict.conflicting_values.items():\n            store = await demo_data_store.get_store(store_id)\n            if store:\n                # Get timestamp from store operations\n                for operation in reversed(store.operations):\n                    if (operation.data_type == conflict.data_type and \n                        operation.key == conflict.key):\n                        if latest_timestamp is None or operation.timestamp > latest_timestamp:\n                            latest_timestamp = operation.timestamp\n                            latest_value = value\n                        break\n                        \n        return latest_value\n        \n    async def _resolve_first_write_wins(self, conflict: ConflictEvent) -> Any:\n        \"\"\"Resolve conflict using first write wins strategy.\"\"\"\n        # Find the earliest value based on timestamps\n        earliest_timestamp = None\n        earliest_value = None\n        \n        for store_id, value in conflict.conflicting_values.items():\n            store = await demo_data_store.get_store(store_id)\n            if store:\n                # Get timestamp from store operations\n                for operation in store.operations:\n                    if (operation.data_type == conflict.data_type and \n                        operation.key == conflict.key):\n                        if earliest_timestamp is None or operation.timestamp < earliest_timestamp:\n                            earliest_timestamp = operation.timestamp\n                            earliest_value = value\n                        break\n                        \n        return earliest_value\n        \n    async def _resolve_merge_values(self, conflict: ConflictEvent) -> Any:\n        \"\"\"Resolve conflict by merging values.\"\"\"\n        try:\n            values = list(conflict.conflicting_values.values())\n            \n            # Handle different value types\n            if all(isinstance(v, dict) for v in values):\n                # Merge dictionaries\n                merged = {}\n                for value in values:\n                    merged.update(value)\n                return merged\n            elif all(isinstance(v, list) for v in values):\n                # Merge lists (remove duplicates)\n                merged = []\n                for value in values:\n                    for item in value:\n                        if item not in merged:\n                            merged.append(item)\n                return merged\n            elif all(isinstance(v, (int, float)) for v in values):\n                # Average numeric values\n                return sum(values) / len(values)\n            else:\n                # Fall back to last write wins\n                return await self._resolve_last_write_wins(conflict)\n                \n        except Exception as e:\n            logger.error(f\"Error merging values: {e}\")\n            return await self._resolve_last_write_wins(conflict)\n            \n    async def _resolve_priority_based(self, conflict: ConflictEvent) -> Any:\n        \"\"\"Resolve conflict based on store priority.\"\"\"\n        # Define store priorities (higher number = higher priority)\n        store_priorities = {\n            \"main\": 100,\n            \"demo\": 90,\n            \"backup\": 80,\n            \"temp\": 70\n        }\n        \n        highest_priority = -1\n        priority_value = None\n        \n        for store_id, value in conflict.conflicting_values.items():\n            priority = store_priorities.get(store_id, 50)  # Default priority\n            if priority > highest_priority:\n                highest_priority = priority\n                priority_value = value\n                \n        return priority_value or await self._resolve_last_write_wins(conflict)\n        \n    async def _sync_loop(self):\n        \"\"\"Background sync loop.\"\"\"\n        try:\n            while True:\n                await asyncio.sleep(self.config[\"sync_interval\"])\n                \n                # Process sync rules\n                for rule_id, rule_config in self.sync_rules.items():\n                    try:\n                        await self._process_sync_rule(rule_id, rule_config)\n                    except Exception as e:\n                        logger.error(f\"Error processing sync rule {rule_id}: {e}\")\n                        \n        except asyncio.CancelledError:\n            pass\n        except Exception as e:\n            logger.error(f\"Sync loop error: {e}\")\n            \n    async def _process_sync_rule(self, rule_id: str, rule_config: Dict[str, Any]):\n        \"\"\"Process a synchronization rule.\"\"\"\n        # This would implement rule-based synchronization\n        # For now, it's a placeholder for future enhancement\n        pass\n        \n    async def _conflict_resolution_loop(self):\n        \"\"\"Background conflict resolution loop.\"\"\"\n        try:\n            while True:\n                await asyncio.sleep(5.0)  # Check every 5 seconds\n                \n                # Check for expired conflicts\n                now = datetime.utcnow()\n                expired_conflicts = []\n                \n                for conflict_id, conflict in self.conflicts.items():\n                    if not conflict.resolved:\n                        age = (now - conflict.timestamp).total_seconds()\n                        if age > self.config[\"conflict_timeout\"]:\n                            expired_conflicts.append(conflict_id)\n                            \n                # Handle expired conflicts\n                for conflict_id in expired_conflicts:\n                    conflict = self.conflicts[conflict_id]\n                    logger.warning(f\"Conflict {conflict_id} expired, using default resolution\")\n                    await self._handle_conflict(conflict)\n                    \n        except asyncio.CancelledError:\n            pass\n        except Exception as e:\n            logger.error(f\"Conflict resolution loop error: {e}\")\n            \n    async def add_subscriber(self, callback: Callable):\n        \"\"\"Add a subscriber for sync events.\"\"\"\n        self.subscribers.append(callback)\n        \n    async def _notify_subscribers(self, sync_event: SyncEvent):\n        \"\"\"Notify subscribers of sync events.\"\"\"\n        for callback in self.subscribers:\n            try:\n                if asyncio.iscoroutinefunction(callback):\n                    await callback(sync_event)\n                else:\n                    callback(sync_event)\n            except Exception as e:\n                logger.error(f\"Subscriber callback error: {e}\")\n                \n    async def get_sync_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get synchronization statistics.\"\"\"\n        return {\n            \"sync_groups\": len(self.sync_groups),\n            \"sync_rules\": len(self.sync_rules),\n            \"total_sync_events\": len(self.sync_events),\n            \"active_conflicts\": len([c for c in self.conflicts.values() if not c.resolved]),\n            \"resolved_conflicts\": len([c for c in self.conflicts.values() if c.resolved]),\n            \"subscribers\": len(self.subscribers)\n        }\n        \n    async def get_conflict_summary(self) -> Dict[str, Any]:\n        \"\"\"Get summary of conflicts.\"\"\"\n        active_conflicts = [c for c in self.conflicts.values() if not c.resolved]\n        resolved_conflicts = [c for c in self.conflicts.values() if c.resolved]\n        \n        return {\n            \"active_conflicts\": len(active_conflicts),\n            \"resolved_conflicts\": len(resolved_conflicts),\n            \"conflicts_by_type\": {\n                data_type.value: len([c for c in self.conflicts.values() \n                                    if c.data_type == data_type])\n                for data_type in DataType\n            },\n            \"conflicts_by_resolution\": {\n                resolution.value: len([c for c in resolved_conflicts \n                                     if c.resolution_strategy == resolution])\n                for resolution in ConflictResolution\n            }\n        }\n\n\n# Global data sync service instance\ndata_sync_service = DataSyncService()"