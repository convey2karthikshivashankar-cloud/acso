import React from 'react';
import { screen, fireEvent, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { renderWithProviders, mockAgent, mockIncident, mockWorkflow } from '../utils/testHelpers';
import App from '../../App';

// Mock the services for E2E testing
const mockServices = {
  authService: {
    login: jest.fn().mockResolvedValue({
      user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },
      token: 'mock-token',
    }),
    logout: jest.fn().mockResolvedValue(undefined),
    getCurrentUser: jest.fn().mockResolvedValue({
      id: '1',
      email: 'test@example.com',
      name: 'Test User',
      role: 'admin',
    }),
  },
  agentService: {
    getAgents: jest.fn().mockResolvedValue([
      mockAgent({ id: 'agent1', name: 'Security Agent 1', status: 'online' }),
      mockAgent({ id: 'agent2', name: 'Threat Hunter 2', status: 'offline' }),
    ]),
    updateAgent: jest.fn().mockResolvedValue(mockAgent()),
    configureAgent: jest.fn().mockResolvedValue(mockAgent()),
  },
  incidentService: {
    getIncidents: jest.fn().mockResolvedValue([
      mockIncident({ id: 'inc1', title: 'Security Breach', severity: 'high' }),
      mockIncident({ id: 'inc2', title: 'Performance Issue', severity: 'medium' }),
    ]),
    createIncident: jest.fn().mockResolvedValue(mockIncident()),
    updateIncident: jest.fn().mockResolvedValue(mockIncident()),
  },
  workflowService: {
    getWorkflows: jest.fn().mockResolvedValue([
      mockWorkflow({ id: 'wf1', name: 'Incident Response', status: 'running' }),
      mockWorkflow({ id: 'wf2', name: 'Threat Analysis', status: 'completed' }),
    ]),
    createWorkflow: jest.fn().mockResolvedValue(mockWorkflow()),
    executeWorkflow: jest.fn().mockResolvedValue(mockWorkflow()),
  },
};\n\n// Mock all service modules\njest.mock('../../services/authService', () => ({ authService: mockServices.authService }));\njest.mock('../../services/agentService', () => ({ agentService: mockServices.agentService }));\njest.mock('../../services/incidentService', () => ({ incidentService: mockServices.incidentService }));\njest.mock('../../services/workflowService', () => ({ workflowService: mockServices.workflowService }));\n\n// Mock WebSocket and real-time services\njest.mock('../../services/websocketService', () => ({\n  websocketService: {\n    connect: jest.fn().mockResolvedValue(undefined),\n    disconnect: jest.fn(),\n    onMessage: jest.fn().mockReturnValue(() => {}),\n    isConnected: jest.fn().mockReturnValue(true),\n  },\n}));\n\njest.mock('../../services/realTimeDataService', () => ({\n  realTimeDataService: {\n    initialize: jest.fn().mockResolvedValue(undefined),\n    onMessage: jest.fn().mockReturnValue(() => {}),\n  },\n}));\n\ndescribe('User Journey E2E Tests', () => {\n  const user = userEvent.setup();\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // Reset localStorage\n    localStorage.clear();\n  });\n\n  describe('Authentication Flow', () => {\n    it('should complete full login and logout flow', async () => {\n      renderWithProviders(<App />, {\n        initialState: {\n          auth: {\n            isAuthenticated: false,\n            user: null,\n            token: null,\n            loading: false,\n            error: null,\n          },\n        },\n      });\n\n      // Should show login page\n      expect(screen.getByRole('heading', { name: /sign in/i })).toBeInTheDocument();\n\n      // Fill in login form\n      const emailInput = screen.getByLabelText(/email/i);\n      const passwordInput = screen.getByLabelText(/password/i);\n      const loginButton = screen.getByRole('button', { name: /sign in/i });\n\n      await user.type(emailInput, 'test@example.com');\n      await user.type(passwordInput, 'password123');\n      await user.click(loginButton);\n\n      // Should call login service\n      await waitFor(() => {\n        expect(mockServices.authService.login).toHaveBeenCalledWith({\n          email: 'test@example.com',\n          password: 'password123',\n        });\n      });\n\n      // Should redirect to dashboard after successful login\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Test logout\n      const userMenu = screen.getByRole('button', { name: /user menu/i });\n      await user.click(userMenu);\n\n      const logoutButton = screen.getByRole('menuitem', { name: /logout/i });\n      await user.click(logoutButton);\n\n      // Should call logout service and redirect to login\n      await waitFor(() => {\n        expect(mockServices.authService.logout).toHaveBeenCalled();\n        expect(screen.getByRole('heading', { name: /sign in/i })).toBeInTheDocument();\n      });\n    });\n\n    it('should handle login errors gracefully', async () => {\n      mockServices.authService.login.mockRejectedValueOnce(new Error('Invalid credentials'));\n\n      renderWithProviders(<App />, {\n        initialState: {\n          auth: {\n            isAuthenticated: false,\n            user: null,\n            token: null,\n            loading: false,\n            error: null,\n          },\n        },\n      });\n\n      // Fill in login form with invalid credentials\n      const emailInput = screen.getByLabelText(/email/i);\n      const passwordInput = screen.getByLabelText(/password/i);\n      const loginButton = screen.getByRole('button', { name: /sign in/i });\n\n      await user.type(emailInput, 'invalid@example.com');\n      await user.type(passwordInput, 'wrongpassword');\n      await user.click(loginButton);\n\n      // Should show error message\n      await waitFor(() => {\n        expect(screen.getByText(/invalid credentials/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Dashboard Navigation', () => {\n    const authenticatedState = {\n      auth: {\n        isAuthenticated: true,\n        user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },\n        token: 'mock-token',\n        loading: false,\n        error: null,\n      },\n    };\n\n    it('should navigate between main sections', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Should start on dashboard\n      expect(screen.getByText(/system overview/i)).toBeInTheDocument();\n\n      // Navigate to agents\n      const agentsLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(agentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText(/agent management/i)).toBeInTheDocument();\n      });\n\n      // Navigate to incidents\n      const incidentsLink = screen.getByRole('link', { name: /incidents/i });\n      await user.click(incidentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText(/incident management/i)).toBeInTheDocument();\n      });\n\n      // Navigate to workflows\n      const workflowsLink = screen.getByRole('link', { name: /workflows/i });\n      await user.click(workflowsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText(/workflow management/i)).toBeInTheDocument();\n      });\n    });\n\n    it('should handle breadcrumb navigation', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to agent details\n      const agentsLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(agentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText(/agent management/i)).toBeInTheDocument();\n      });\n\n      // Click on an agent to view details\n      const agentCard = screen.getByText('Security Agent 1');\n      await user.click(agentCard);\n\n      await waitFor(() => {\n        expect(screen.getByText(/agent details/i)).toBeInTheDocument();\n      });\n\n      // Use breadcrumb to navigate back\n      const breadcrumbLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(breadcrumbLink);\n\n      await waitFor(() => {\n        expect(screen.getByText(/agent management/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Agent Management Workflow', () => {\n    const authenticatedState = {\n      auth: {\n        isAuthenticated: true,\n        user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },\n        token: 'mock-token',\n        loading: false,\n        error: null,\n      },\n      agents: {\n        agents: [\n          mockAgent({ id: 'agent1', name: 'Security Agent 1', status: 'online' }),\n          mockAgent({ id: 'agent2', name: 'Threat Hunter 2', status: 'offline' }),\n        ],\n        loading: false,\n        error: null,\n      },\n    };\n\n    it('should complete agent configuration workflow', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to agents\n      const agentsLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(agentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText('Security Agent 1')).toBeInTheDocument();\n      });\n\n      // Click configure button for an agent\n      const configureButton = screen.getByRole('button', { name: /configure agent1/i });\n      await user.click(configureButton);\n\n      // Should open configuration dialog\n      await waitFor(() => {\n        expect(screen.getByRole('dialog', { name: /agent configuration/i })).toBeInTheDocument();\n      });\n\n      // Fill in configuration form\n      const nameInput = screen.getByLabelText(/agent name/i);\n      await user.clear(nameInput);\n      await user.type(nameInput, 'Updated Security Agent');\n\n      const intervalInput = screen.getByLabelText(/update interval/i);\n      await user.clear(intervalInput);\n      await user.type(intervalInput, '30');\n\n      // Save configuration\n      const saveButton = screen.getByRole('button', { name: /save configuration/i });\n      await user.click(saveButton);\n\n      // Should call update service\n      await waitFor(() => {\n        expect(mockServices.agentService.configureAgent).toHaveBeenCalledWith(\n          'agent1',\n          expect.objectContaining({\n            name: 'Updated Security Agent',\n            updateInterval: 30,\n          })\n        );\n      });\n\n      // Should close dialog and show success message\n      await waitFor(() => {\n        expect(screen.queryByRole('dialog')).not.toBeInTheDocument();\n        expect(screen.getByText(/configuration updated successfully/i)).toBeInTheDocument();\n      });\n    });\n\n    it('should handle agent status changes', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to agents\n      const agentsLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(agentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText('Threat Hunter 2')).toBeInTheDocument();\n      });\n\n      // Click start button for offline agent\n      const startButton = screen.getByRole('button', { name: /start agent2/i });\n      await user.click(startButton);\n\n      // Should call update service\n      await waitFor(() => {\n        expect(mockServices.agentService.updateAgent).toHaveBeenCalledWith(\n          'agent2',\n          expect.objectContaining({ status: 'online' })\n        );\n      });\n    });\n  });\n\n  describe('Incident Management Workflow', () => {\n    const authenticatedState = {\n      auth: {\n        isAuthenticated: true,\n        user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },\n        token: 'mock-token',\n        loading: false,\n        error: null,\n      },\n      incidents: {\n        incidents: [\n          mockIncident({ id: 'inc1', title: 'Security Breach', severity: 'high', status: 'open' }),\n          mockIncident({ id: 'inc2', title: 'Performance Issue', severity: 'medium', status: 'investigating' }),\n        ],\n        loading: false,\n        error: null,\n      },\n    };\n\n    it('should complete incident creation workflow', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to incidents\n      const incidentsLink = screen.getByRole('link', { name: /incidents/i });\n      await user.click(incidentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText('Security Breach')).toBeInTheDocument();\n      });\n\n      // Click create incident button\n      const createButton = screen.getByRole('button', { name: /create incident/i });\n      await user.click(createButton);\n\n      // Should open incident creation form\n      await waitFor(() => {\n        expect(screen.getByRole('dialog', { name: /create incident/i })).toBeInTheDocument();\n      });\n\n      // Fill in incident form\n      const titleInput = screen.getByLabelText(/incident title/i);\n      await user.type(titleInput, 'New Security Incident');\n\n      const descriptionInput = screen.getByLabelText(/description/i);\n      await user.type(descriptionInput, 'Suspicious activity detected on server');\n\n      const severitySelect = screen.getByLabelText(/severity/i);\n      await user.selectOptions(severitySelect, 'high');\n\n      const categorySelect = screen.getByLabelText(/category/i);\n      await user.selectOptions(categorySelect, 'security');\n\n      // Submit form\n      const submitButton = screen.getByRole('button', { name: /create incident/i });\n      await user.click(submitButton);\n\n      // Should call create service\n      await waitFor(() => {\n        expect(mockServices.incidentService.createIncident).toHaveBeenCalledWith(\n          expect.objectContaining({\n            title: 'New Security Incident',\n            description: 'Suspicious activity detected on server',\n            severity: 'high',\n            category: 'security',\n          })\n        );\n      });\n\n      // Should close dialog and show success message\n      await waitFor(() => {\n        expect(screen.queryByRole('dialog')).not.toBeInTheDocument();\n        expect(screen.getByText(/incident created successfully/i)).toBeInTheDocument();\n      });\n    });\n\n    it('should handle incident status updates', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to incidents\n      const incidentsLink = screen.getByRole('link', { name: /incidents/i });\n      await user.click(incidentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText('Security Breach')).toBeInTheDocument();\n      });\n\n      // Click on incident to view details\n      const incidentCard = screen.getByText('Security Breach');\n      await user.click(incidentCard);\n\n      await waitFor(() => {\n        expect(screen.getByText(/incident details/i)).toBeInTheDocument();\n      });\n\n      // Update incident status\n      const statusSelect = screen.getByLabelText(/status/i);\n      await user.selectOptions(statusSelect, 'investigating');\n\n      const updateButton = screen.getByRole('button', { name: /update status/i });\n      await user.click(updateButton);\n\n      // Should call update service\n      await waitFor(() => {\n        expect(mockServices.incidentService.updateIncident).toHaveBeenCalledWith(\n          'inc1',\n          expect.objectContaining({ status: 'investigating' })\n        );\n      });\n    });\n  });\n\n  describe('Workflow Management', () => {\n    const authenticatedState = {\n      auth: {\n        isAuthenticated: true,\n        user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },\n        token: 'mock-token',\n        loading: false,\n        error: null,\n      },\n      workflows: {\n        workflows: [\n          mockWorkflow({ id: 'wf1', name: 'Incident Response', status: 'running', progress: 50 }),\n          mockWorkflow({ id: 'wf2', name: 'Threat Analysis', status: 'completed', progress: 100 }),\n        ],\n        loading: false,\n        error: null,\n      },\n    };\n\n    it('should execute workflow successfully', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to workflows\n      const workflowsLink = screen.getByRole('link', { name: /workflows/i });\n      await user.click(workflowsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText('Incident Response')).toBeInTheDocument();\n      });\n\n      // Click execute button for a workflow\n      const executeButton = screen.getByRole('button', { name: /execute wf1/i });\n      await user.click(executeButton);\n\n      // Should show confirmation dialog\n      await waitFor(() => {\n        expect(screen.getByRole('dialog', { name: /confirm execution/i })).toBeInTheDocument();\n      });\n\n      // Confirm execution\n      const confirmButton = screen.getByRole('button', { name: /confirm/i });\n      await user.click(confirmButton);\n\n      // Should call execute service\n      await waitFor(() => {\n        expect(mockServices.workflowService.executeWorkflow).toHaveBeenCalledWith('wf1');\n      });\n\n      // Should show success message\n      await waitFor(() => {\n        expect(screen.getByText(/workflow executed successfully/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Search and Filtering', () => {\n    const authenticatedState = {\n      auth: {\n        isAuthenticated: true,\n        user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },\n        token: 'mock-token',\n        loading: false,\n        error: null,\n      },\n      agents: {\n        agents: [\n          mockAgent({ id: 'agent1', name: 'Security Agent 1', type: 'security', status: 'online' }),\n          mockAgent({ id: 'agent2', name: 'Threat Hunter 2', type: 'threat-detection', status: 'offline' }),\n          mockAgent({ id: 'agent3', name: 'Performance Monitor', type: 'monitoring', status: 'online' }),\n        ],\n        loading: false,\n        error: null,\n      },\n    };\n\n    it('should filter agents by search term', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to agents\n      const agentsLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(agentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText('Security Agent 1')).toBeInTheDocument();\n        expect(screen.getByText('Threat Hunter 2')).toBeInTheDocument();\n        expect(screen.getByText('Performance Monitor')).toBeInTheDocument();\n      });\n\n      // Search for 'Security'\n      const searchInput = screen.getByPlaceholderText(/search agents/i);\n      await user.type(searchInput, 'Security');\n\n      // Should filter results\n      await waitFor(() => {\n        expect(screen.getByText('Security Agent 1')).toBeInTheDocument();\n        expect(screen.queryByText('Threat Hunter 2')).not.toBeInTheDocument();\n        expect(screen.queryByText('Performance Monitor')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should filter agents by status', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to agents\n      const agentsLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(agentsLink);\n\n      await waitFor(() => {\n        expect(screen.getByText('Security Agent 1')).toBeInTheDocument();\n      });\n\n      // Apply status filter\n      const statusFilter = screen.getByLabelText(/filter by status/i);\n      await user.selectOptions(statusFilter, 'online');\n\n      // Should show only online agents\n      await waitFor(() => {\n        expect(screen.getByText('Security Agent 1')).toBeInTheDocument();\n        expect(screen.getByText('Performance Monitor')).toBeInTheDocument();\n        expect(screen.queryByText('Threat Hunter 2')).not.toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Real-Time Updates', () => {\n    const authenticatedState = {\n      auth: {\n        isAuthenticated: true,\n        user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },\n        token: 'mock-token',\n        loading: false,\n        error: null,\n      },\n    };\n\n    it('should handle real-time notifications', async () => {\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Should show notification center\n      expect(screen.getByRole('button', { name: /notifications/i })).toBeInTheDocument();\n\n      // Simulate real-time notification\n      const notificationEvent = new CustomEvent('notification', {\n        detail: {\n          type: 'incident_created',\n          title: 'New Security Incident',\n          message: 'A new high-severity incident has been created',\n          severity: 'high',\n        },\n      });\n\n      window.dispatchEvent(notificationEvent);\n\n      // Should show notification\n      await waitFor(() => {\n        expect(screen.getByText(/new security incident/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle network errors gracefully', async () => {\n      // Mock network error\n      mockServices.agentService.getAgents.mockRejectedValueOnce(new Error('Network error'));\n\n      const authenticatedState = {\n        auth: {\n          isAuthenticated: true,\n          user: { id: '1', email: 'test@example.com', name: 'Test User', role: 'admin' },\n          token: 'mock-token',\n          loading: false,\n          error: null,\n        },\n      };\n\n      renderWithProviders(<App />, { initialState: authenticatedState });\n\n      // Navigate to agents\n      const agentsLink = screen.getByRole('link', { name: /agents/i });\n      await user.click(agentsLink);\n\n      // Should show error message\n      await waitFor(() => {\n        expect(screen.getByText(/network error/i)).toBeInTheDocument();\n      });\n\n      // Should show retry button\n      const retryButton = screen.getByRole('button', { name: /retry/i });\n      expect(retryButton).toBeInTheDocument();\n\n      // Reset mock to succeed on retry\n      mockServices.agentService.getAgents.mockResolvedValueOnce([\n        mockAgent({ id: 'agent1', name: 'Security Agent 1' }),\n      ]);\n\n      // Click retry\n      await user.click(retryButton);\n\n      // Should load data successfully\n      await waitFor(() => {\n        expect(screen.getByText('Security Agent 1')).toBeInTheDocument();\n      });\n    });\n  });\n});"